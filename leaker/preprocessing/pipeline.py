"""
For License information see the LICENSE file.

Authors: Johannes Leupold

"""
from abc import ABC, abstractmethod
from typing import Iterator, TypeVar, Generic

IN = TypeVar("IN", contravariant=True)
FILTER_IN = TypeVar("FILTER_IN", contravariant=True)
INTERMEDIATE = TypeVar("INTERMEDIATE")
OUT = TypeVar("OUT", covariant=True)
FILTER_OUT = TypeVar("FILTER_OUT", covariant=True)


class Source(ABC, Generic[OUT]):
    """
    The source of a pipeline, i.e. the component generating elements that are pushed through the pipeline.
    """

    @abstractmethod
    def elements(self) -> Iterator[OUT]:
        """
        Yields the elements generated by this source.
        """
        raise NotImplementedError

    def __iter__(self) -> Iterator[OUT]:
        return self.elements()

    def __rshift__(self, sink: 'Sink[OUT]') -> None:
        """
        Pipes the elements of this source into the given `Sink`. The sink must accept the type of elements generated
        by this source.

        Parameters
        ----------
        sink: Sink[OUT]
            The sink to pipe the elements to
        """
        sink.run(self)


class Sink(ABC, Generic[IN]):
    """
    The sink of a pipeline, i.e. the component consuming elements that are pushed through the pipeline.
    """

    @abstractmethod
    def run(self, source: Source[IN]) -> None:
        """
        Consumes the elements from the given `Source`. The source must yield elements of the type this sink accepts.

        Parameters
        ----------
        source: Source[IN]
            The source to consume
        """
        raise NotImplementedError

    def __call__(self, source: Source[IN]) -> None:
        self.run(source)


class Filter(ABC, Generic[IN, OUT]):
    """
    An intermediate stage of a pipeline that may change, extract or inject elements or map them to another type or any
    combination of those operations.
    """

    @abstractmethod
    def filter(self, source: Iterator[IN]) -> Iterator[OUT]:
        """
        Performs the filter's operation on all elements of the input iterator and yields the output elements of the
        filtering operation.

        Parameters
        ----------
        source: Iterator[IN]
            The iterator to filter

        Returns
        -------
        filter: Iterator[OUT]
            The elements created by the filter
        """
        raise NotImplementedError

    def __call__(self, source: Source[IN]) -> Source[OUT]:
        return IterableOnceSource[OUT](self.filter(iter(source)))

    def __or__(self, next_filter: 'Filter[OUT, FILTER_OUT]') -> 'Filter[IN, FILTER_OUT]':
        """
        Concatenates this filter to the `next_filter`.

        Parameters
        ----------
        next_filter: Filter[OUT, FILTER_OUT]
            the filter to attach to this filter

        Returns
        -------
        __or__: Filter[IN, FILTER_OUT]
            The concatenated filter resulting from first running this filter on the elements and then running
            `next_filter` on the resulting elements
        """
        return ComposedFilter(self, next_filter)

    def __gt__(self, sink: Sink[OUT]) -> Sink[IN]:
        """
        Attaches this filter to the given `Sink`, producing a new `Sink` that will first run this filter and then
        consume the elements with the `sink`.

        Parameters
        ----------
        sink: Sink[OUT]
            The sink to attach this filter to

        Returns
        -------
        __gt__: Sink[IN]
            The new sink resulting from first running this filter on the elements and then consuming the resulting
            elements with `sink`.
        """
        return FilteredSink(self, sink)


class IterableOnceSource(Source[OUT]):
    """
    A source yielding from an iterator. This source can only be used once.

    Parameters
    ----------
    iterator: Iterator[OUT]
        The iterator to yield from
    """
    def __init__(self, iterator: Iterator[OUT]):
        self.__iterator: Iterator[OUT] = iterator

    def elements(self) -> Iterator[OUT]:
        return self.__iterator


class ComposedFilter(Generic[IN, INTERMEDIATE, OUT], Filter[IN, OUT]):
    """
    A filter given by executing two compatible filters on the elements sequentially.

    Parameters
    ----------
    first: Filter[IN, INTERMEDIATE]
        The first filter to use
    second: Filter[INTERMEDIATE, OUT]
        The second filter to use
    """
    __first: Filter[IN, INTERMEDIATE]
    __second: Filter[INTERMEDIATE, OUT]

    def __init__(self, first: Filter[IN, INTERMEDIATE], second: Filter[INTERMEDIATE, OUT]):
        self.__first = first
        self.__second = second

    def filter(self, source: Iterator[IN]) -> Iterator[OUT]:
        return self.__second.filter(self.__first.filter(source))


class FilteredSink(Generic[FILTER_IN, FILTER_OUT], Sink[FILTER_IN]):
    """
    A sink given by first applying a filter to the elements and then consuming the resulting elements with a
    compatible sink.

    Parameters
    ----------
    element_filter: Filter[FILTER_IN, FILTER_OUT]
        The filter to apply
    sink: Sink[FILTER_OUT]
        The sink to consume the filter output with
    """
    __filter: Filter[FILTER_IN, FILTER_OUT]
    __sink: Sink[FILTER_OUT]

    def __init__(self, element_filter: Filter[FILTER_IN, FILTER_OUT], sink: Sink[FILTER_OUT]):
        self.__filter = element_filter
        self.__sink = sink

    def run(self, source: Source[FILTER_IN]) -> None:
        self.__sink(self.__filter(source))
